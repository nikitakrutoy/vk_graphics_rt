#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : require

#include "common_generated.h"

struct MaterialData_pbrMR
{
  vec4 baseColor;

  float metallic;
  float roughness;
  int baseColorTexId;
  int metallicRoughnessTexId;

  vec3 emissionColor;
  int emissionTexId;

  int normalTexId;
  int occlusionTexId;
  float alphaCutoff;
  int alphaMode;
};

struct MeshInfo
{
  uint indexOffset;
  uint vertexOffset;
};

struct Vertex {
  vec4 vertex;
  vec4 texCoordAndTangent;
};

layout(binding = 0, set = 0) buffer data0 { uint out_color[]; }; //
layout(binding = 1, set = 0) uniform accelerationStructureEXT m_pAccelStruct;
layout(binding = 2, set = 0) buffer dataUBO { RayTracer_UBO_Data ubo; };
layout(binding = 3, set = 0) buffer Vertices { Vertex vertices[]; };
layout(binding = 4, set = 0) buffer Indices { uint indices[]; };
layout(binding = 5, set = 0) buffer MatIds { uint mat_ids[]; };
layout(binding = 6, set = 0) buffer Materials { MaterialData_pbrMR materials[]; };
layout(binding = 7, set = 0) buffer InstanceMats { mat4 instance_mats[]; };
layout(binding = 8, set = 0) buffer MeshInfos { MeshInfo mesh_infos[]; };
layout(binding = 9, set = 0) uniform texture2D textures[];
layout(binding = 10, set = 0) uniform sampler samp;



uint packColor(vec4 rgba) {
  uvec4 bytes = uvec4(rgba * 255.0f);
  uint result = (bytes.a << 24) | (bytes.b << 16) | (bytes.g << 8) | (bytes.r);
  return result;
}

vec3 DecodeNormal(uint a_data)
{
  const uint a_enc_x = (a_data  & 0x0000FFFFu);
  const uint a_enc_y = ((a_data & 0xFFFF0000u) >> 16);
  const float sign   = (a_enc_x & 0x0001u) != 0 ? -1.0f : 1.0f;

  const int usX = int(a_enc_x & 0x0000FFFEu);
  const int usY = int(a_enc_y & 0x0000FFFFu);

  const int sX  = (usX <= 32767) ? usX : usX - 65536;
  const int sY  = (usY <= 32767) ? usY : usY - 65536;

  const float x = sX*(1.0f / 32767.0f);
  const float y = sY*(1.0f / 32767.0f);
  const float z = sign*sqrt(max(1.0f - x*x - y*y, 0.0f));

  return vec3(x, y, z);
}

vec4 LIGHT_DIR = vec4(normalize(vec3(1.0f, 0.0f, 1.0f)), 0.0f);
vec4 LIGHT_DIR2 = vec4(normalize(vec3(-1.0f, 0.0f, 1.0f)), 0.0f);

// RayScene intersection with 'm_pAccelStruct'
//
CRT_Hit m_pAccelStruct_RayQuery_NearestHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsOpaqueEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  
  while(rayQueryProceedEXT(rayQuery)) { } // actually may omit 'while' when 'gl_RayFlagsOpaqueEXT' is used
 
  CRT_Hit res;
  res.primId = -1;
  res.instId = -1;
  res.geomId = -1;
  res.t      = rayDir.w;

  if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
  {    
	  res.primId    = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	  res.geomId    = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
    res.instId    = rayQueryGetIntersectionInstanceIdEXT    (rayQuery, true);
	  res.t         = rayQueryGetIntersectionTEXT(rayQuery, true);
    res.bars = vec3(0.0, rayQueryGetIntersectionBarycentricsEXT(rayQuery, true));
    res.bars.x    = 1.0 - res.bars.y - res.bars.z;
  }

  return res;
}

bool m_pAccelStruct_RayQuery_AnyHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  rayQueryProceedEXT(rayQuery);
  return (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;


layout( push_constant ) uniform kernelArgs
{
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;


void getPosNormal(CRT_Hit hit, out vec4 p, out vec3 n) {
  uint indexOffset = mesh_infos[hit.geomId].indexOffset;
  uint vertexOffset = mesh_infos[hit.geomId].vertexOffset;

  const uint i0 = indices[indexOffset + 3 * hit.primId + 0];
  const uint i1 = indices[indexOffset + 3 * hit.primId + 1];
  const uint i2 = indices[indexOffset + 3 * hit.primId + 2];

  const vec4 v0 = vertices[vertexOffset + i0].vertex;
  const vec4 v1 = vertices[vertexOffset + i1].vertex;
  const vec4 v2 = vertices[vertexOffset + i2].vertex;

  const vec4 n0 = vec4(DecodeNormal(floatBitsToInt(v0.w)), 0);
  const vec4 n1 = vec4(DecodeNormal(floatBitsToInt(v1.w)), 0);
  const vec4 n2 = vec4(DecodeNormal(floatBitsToInt(v2.w)), 0);
  
  vec3 p_local = hit.bars.x * v0.xyz + hit.bars.y * v1.xyz + hit.bars.z * v2.xyz;
  vec3 n_local = hit.bars.x * n0.xyz + hit.bars.y * n1.xyz + hit.bars.z * n2.xyz;

  n = normalize(mat3(transpose(inverse(instance_mats[hit.instId]))) * n_local.xyz);
  p = instance_mats[hit.instId] * vec4(p_local.xyz, 1.0f);
}

vec4 shade(CRT_Hit hit) {

  if (hit.primId == -1)
    return vec4(0.5);

  uint indexOffset = mesh_infos[hit.geomId].indexOffset;
  uint primOffset = indexOffset / 3;

  uint mat_id = mat_ids[primOffset + hit.primId];

  vec4 p;
  vec3 n;
  getPosNormal(hit, p, n);
  vec4 rayPos = p;
  vec4 rayDir = LIGHT_DIR;
  rayPos.w = 1.0f;
  rayDir.w = MAXFLOAT;

  bool occoluded = m_pAccelStruct_RayQuery_AnyHit(rayPos, rayDir);

  if (occoluded) 
    return vec4(0.0f);

  float shade = max(dot(n, LIGHT_DIR.xyz), 0.0f);

  vec4 baseColor;
  if (materials[mat_id].baseColorTexId >= 0) {
    uint indexOffset = mesh_infos[hit.geomId].indexOffset;
    uint vertexOffset = mesh_infos[hit.geomId].vertexOffset;

    const uint i0 = indices[indexOffset + 3 * hit.primId + 0];
    const uint i1 = indices[indexOffset + 3 * hit.primId + 1];
    const uint i2 = indices[indexOffset + 3 * hit.primId + 2];

    const vec2 uv0 = vertices[vertexOffset + i0].texCoordAndTangent.xy;
    const vec2 uv1 = vertices[vertexOffset + i1].texCoordAndTangent.xy;
    const vec2 uv2 = vertices[vertexOffset + i2].texCoordAndTangent.xy;
    vec2 uv =  hit.bars.x * uv0 + hit.bars.y * uv1 + hit.bars.z * uv2;
    baseColor = texture(sampler2D(textures[materials[mat_id].baseColorTexId], samp), uv);
  }
  else {
    baseColor = materials[mat_id].baseColor;
  }
  return shade * baseColor;
}

#define PI 3.1415926

vec3 fresnel ( in vec3 f0, in float product )
{
	// product = clamp ( product, 0.0, 1.0 );		// saturate
	
	return mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );
}

vec3 fresnel_factor(in vec3 f0, in float product)
{
    return mix(f0, vec3(1.0), pow(1.01 - product, 5.0));
}


float D_beckmann(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float NdH2 = NdH * NdH;
    return exp((NdH2 - 1.0) / (m2 * NdH2)) / (PI * m2 * NdH2 * NdH2);
}

float D_GGX(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float d = (NdH * m2 - NdH) * NdH + 1.0;
    return m2 / (PI * d * d);
}

float G_schlick(in float roughness, in float NdV, in float NdL)
{
    float k = roughness * roughness * 0.5;
    float V = NdV * (1.0 - k) + k;
    float L = NdL * (1.0 - k) + k;
    return 0.25 / (V * L);
}

vec3 cooktorrance_specular(in float NdL, in float NdV, in float NdH, in vec3 specular, in float roughness)
{
    float D = D_GGX(roughness, NdH);

    float G = G_schlick(roughness, NdV, NdL);

    float rim = NdV;

    return (1.0 / rim) * specular * G * D;
}

vec4 shade_pbr(CRT_Hit hit, vec4 light) {
  uint indexOffset = mesh_infos[hit.geomId].indexOffset;
  uint vertexOffset = mesh_infos[hit.geomId].vertexOffset;
  uint primOffset = indexOffset / 3;

  uint mat_id = mat_ids[primOffset + hit.primId];
  MaterialData_pbrMR mat = materials[mat_id];

  if (hit.primId == -1)
    return vec4(0.0);

  vec4 p;
  vec3 n;
  getPosNormal(hit, p, n);

  vec4 rayPos = p;
  vec4 rayDir = light;
  rayPos.w = 1.0f;
  rayDir.w = MAXFLOAT;

  bool occoluded = m_pAccelStruct_RayQuery_AnyHit(rayPos, rayDir);

  if (occoluded) 
    return vec4(0.0f);

  const uint i0 = indices[indexOffset + 3 * hit.primId + 0];
  const uint i1 = indices[indexOffset + 3 * hit.primId + 1];
  const uint i2 = indices[indexOffset + 3 * hit.primId + 2];

  const vec2 uv0 = vertices[vertexOffset + i0].texCoordAndTangent.xy;
  const vec2 uv1 = vertices[vertexOffset + i1].texCoordAndTangent.xy;
  const vec2 uv2 = vertices[vertexOffset + i2].texCoordAndTangent.xy;

  const vec3 tan0 = DecodeNormal(floatBitsToInt(vertices[vertexOffset + i0].texCoordAndTangent.z));
  const vec3 tan1 = DecodeNormal(floatBitsToInt(vertices[vertexOffset + i1].texCoordAndTangent.z));
  const vec3 tan2 = DecodeNormal(floatBitsToInt(vertices[vertexOffset + i2].texCoordAndTangent.z));

  vec2 uv =  hit.bars.x * uv0 + hit.bars.y * uv1 + hit.bars.z * uv2;
  vec3 T =  hit.bars.x * tan0 + hit.bars.y * tan1 + hit.bars.z * tan2;

  // base
  vec4 base;
  if (mat.baseColorTexId >= 0) {
    base = texture(sampler2D(textures[mat.baseColorTexId], samp), uv);
  }
  else {
    base = mat.baseColor;
  }

  float metallic;
  if (mat.metallicRoughnessTexId >= 0) {
    metallic = texture(sampler2D(textures[mat.metallicRoughnessTexId], samp), uv).b;
  }
  else {
    metallic = mat.metallic;
  }
  
  float roughness;
  if (mat.metallicRoughnessTexId >= 0) {
    roughness = texture(sampler2D(textures[mat.metallicRoughnessTexId], samp), uv).g;
  }
  else {
    roughness = mat.roughness;
  }

  vec3 N = n;
  if (mat.normalTexId >= 0) {
    mat3 M = mat3(transpose(inverse(instance_mats[hit.instId])));
    vec3 B = cross(N, T);
    N = normalize(M * N);
    T = normalize(M * T);
    B = normalize(M * B);
    mat3 TBN = mat3(T, B, N);

    N = normalize(texture(sampler2D(textures[mat.normalTexId], samp), uv).xyz);

    N = normalize(TBN * N);
  }
  else {
    N = n;
  }

  vec3 V =  -normalize(p.xyz - ubo.m_camPos.xyz);
  vec3 L = light.xyz;
  vec3 H = normalize(L + V);

  float NdL = max(0.0, dot(N, L));
  float NdV = max(0.001, dot(N, V));
  float NdH = max(0.001, dot(N, H));
  float HdV = max(0.001, dot(H, V));

  vec3 specular = mix(vec3(0.04), base.xyz, metallic);
  vec3 specfresnel = clamp(fresnel_factor(specular, HdV), 0.0, 1.0);
  vec3 specref = cooktorrance_specular(NdL, NdV, NdH, specfresnel, roughness);
  specref *= vec3(NdL);

  vec3 diffref = (vec3(1.0) - specfresnel) * NdL / PI;

  specref = clamp(specref, 0.0, 1.0);
  diffref = clamp(diffref, 0.0, 1.0);
  
  vec3 result = diffref * mix(base.xyz, vec3(0.0), metallic) + specref;

  return vec4(result, 1.0);
}

#define HOPS 2
///////////////////////////////////////////////////////////////// subkernels here
void kernel_RayTrace_out_color(uint tidX, uint tidY, in vec4 rayPosAndNear, in vec4 rayDirAndFar, uint out_colorOffset) 
{
  
  vec4 rayPos = rayPosAndNear;
  vec4 rayDir = rayDirAndFar ;
  CRT_Hit hit;

  uint indexOffset;
  uint vertexOffset;
  uint primOffset;

  vec4 p;
  vec3 n;
  uint mat_id;
  MaterialData_pbrMR mat;
  float metallic = 1.0f;
  vec4 color = vec4(0.0f);
  bool cast_ray = true;

  uint hops = 0;

  do 
  {
    hit = m_pAccelStruct_RayQuery_NearestHit(rayPos, rayDir); 
    if (hit.primId != -1) {
      color += metallic * clamp(shade_pbr(hit, LIGHT_DIR), 0.0f, 1.0f);
      color += metallic * clamp(shade_pbr(hit, LIGHT_DIR2), 0.0f, 1.0f);
    }
    else if (hops == 0)
      color = vec4(0.5);

    hops += 1;

    indexOffset = mesh_infos[hit.geomId].indexOffset;
    vertexOffset = mesh_infos[hit.geomId].vertexOffset;
    primOffset = indexOffset / 3;

    mat_id = mat_ids[primOffset + hit.primId];
    mat = materials[mat_id];
    getPosNormal(hit, p, n);
    rayPos = p;
    rayDir = vec4(reflect(rayDir.xyz, n), 0.0f);
    rayPos.w = 0.1f;
    rayDir.w = MAXFLOAT;

    if (mat.metallicRoughnessTexId >= 0) {
      const uint i0 = indices[indexOffset + 3 * hit.primId + 0];
      const uint i1 = indices[indexOffset + 3 * hit.primId + 1];
      const uint i2 = indices[indexOffset + 3 * hit.primId + 2];

      const vec2 uv0 = vertices[vertexOffset + i0].texCoordAndTangent.xy;
      const vec2 uv1 = vertices[vertexOffset + i1].texCoordAndTangent.xy;
      const vec2 uv2 = vertices[vertexOffset + i2].texCoordAndTangent.xy;

      vec2 uv =  hit.bars.x * uv0 + hit.bars.y * uv1 + hit.bars.z * uv2;

      metallic = texture(sampler2D(textures[mat.metallicRoughnessTexId], samp), uv).b;
    }
    else {
      metallic = mat.metallic;
    }

  } while (metallic > 0.0 && hops < HOPS && hit.primId != -1);

  out_color[tidY * ubo.m_width + tidX + out_colorOffset] = packColor(clamp(color, 0.0, 1.0));
}

void kernel_InitEyeRay(uint tidX, uint tidY, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar) 
{
  
  rayPosAndNear = ubo.m_camPos; // to_float4(m_camPos, 1.0f);
  
  const vec3 rayDir = EyeRayDir(float(tidX), float(tidY), float(ubo.m_width), float(ubo.m_height), ubo.m_invProjView);
  rayDirAndFar  = vec4(rayDir, MAXFLOAT);

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tidX = uint(gl_GlobalInvocationID[0]); 
  const uint tidY = uint(gl_GlobalInvocationID[1]); 
  const vec4 m_camPos = ubo.m_camPos;
  const uint m_height = ubo.m_height;
  const uint m_width = ubo.m_width;
  ///////////////////////////////////////////////////////////////// prolog

  
  vec4 rayPosAndNear,  rayDirAndFar;
  kernel_InitEyeRay(tidX, tidY, rayPosAndNear, rayDirAndFar);

  kernel_RayTrace_out_color(tidX, tidY, rayPosAndNear, rayDirAndFar, 0);

}

